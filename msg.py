
## Master file
# All domain names will be 256 characters or less

# You may assume that the resource records contained within any
# message, stripped of any whitespace between the fields, will not exceed 2048 bytes.


## header
# qid: A 16-bit unsigned integer, randomly generated by the client, as an identifier for the query.


## question section
# qtype
# qname

# size

# header 16 bit

import struct

QTYPE_TO_ID = {"A": 1, "NS": 2, "CNAME": 5}
ID_TO_QTYPE = {1: "A", 2: "NS", 5: "CNAME"}
RTYPE_TO_ID = {"answer": 1, "authority": 2, "additional": 3}
ID_TO_RTYPE = {1: "answer" , 2: "authority", 3: "additional"}

class Header:
    def __init__(self, size: int, qid: int):
        self.size = size
        self.qid = qid

    def toBytes(self):
        ba = bytearray()
        # size - unsigned short
        ba.extend(struct.pack('<H', self.size))
        # qid - unsigned short
        ba.extend(struct.pack('<H', self.qid))
        return bytes(ba)

    @staticmethod
    def fromBytes(self, data):
        size = struct.unpack_from('<H', data, 0)[0]
        qid = struct.unpack_from('<H', data, 2)[0]
        return Header(size, qid)


class Question:
    def __init__(self, qtype: str, qname: str):
        self.qtype = qtype
        self.qname = qname

    def toBytes(self):
        ba = bytearray()
        ba.extend(struct.pack('<H', len(self.qname)))
        ba.extend(struct.pack('<H', QTYPE_TO_ID[self.qtype]))
        ba.extend(struct.pack(f'<{len(self.qname)}s', self.qname))
        return bytes(ba)

    @staticmethod
    def fromBytes(self, data):
        size = struct.unpack_from('<H', data, 0)[0]
        qtype_id = struct.unpack_from('<H', data, 2)[0]
        qname = struct.unpack_from(f'<{size}s', data, 4)[0]
        return Question(ID_TO_QTYPE[qtype_id], qname)

class ResourceRecord:
    def __init__(self, rtype: str, records: str):
        self.rtype = rtype
        self.records = records

    def toBytes(self):
        ba = bytearray()
        ba.extend(struct.pack('<H', len(self.records)))
        ba.extend(struct.pack('<H', RTYPE_TO_ID[self.rtype]))
        ba.extend(struct.pack(f'<{len(self.records)}s', self.records))
        return bytes(ba)

    @staticmethod
    def fromBytes(self, data):
        size = struct.unpack_from('<H', data, 0)[0]
        rtype_id = struct.unpack_from('<H', data, 2)[0]
        records = struct.unpack_from(f'<{size}s', data, 4)[0]
        return Question(ID_TO_RTYPE[rtype_id], records)